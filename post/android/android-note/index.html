<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Android Note - KALAQIAE</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="Kalaqiae"><meta name=description content="Android 四大组件 Activity 生命周期 启动模式（standard，singleTop，singleTask，singleInstance） 任务栈 启动方式：显式 Intent，隐式 Intent（Intent Filter，URL Scheme，跨应用场景用隐式），ARouter PendingIntent 数据传递 startActivityForResult 启动一个 Activity 并等待结果。注意：startActivityForResult() 在 Android 11 及以上版本已被弃用，推荐使用 ActivityResultContracts 替代 Fragment 生命周期（onAttach，onCreate，onCreateView，onActivityCreated，onStart，onResume，onPause，onStop，onDestroyView，onDestroy，onDetach） 通信 DialogFragment() onConfigurationChanged onSaveInstanceState "><meta name=keywords content="Hugo,theme,even"><meta name=generator content="Hugo 0.108.0 with theme even"><link rel=canonical href=https://kalaqiae.com/post/android/android-note/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<link href=/sass/main.min.64cde2c5850b06d3c56f0c74b725d4bdf393df50c9a92b98ffd59a4d5eefab93.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="Android Note"><meta property="og:description" content="Android 四大组件

Activity

生命周期
启动模式（standard，singleTop，singleTask，singleInstance）
任务栈
启动方式：显式 Intent，隐式 Intent（Intent Filter，URL Scheme，跨应用场景用隐式），ARouter
PendingIntent
数据传递
startActivityForResult
启动一个 Activity 并等待结果。注意：startActivityForResult() 在 Android 11 及以上版本已被弃用，推荐使用 ActivityResultContracts 替代
Fragment

生命周期（onAttach，onCreate，onCreateView，onActivityCreated，onStart，onResume，onPause，onStop，onDestroyView，onDestroy，onDetach）
通信
DialogFragment()


onConfigurationChanged
onSaveInstanceState


"><meta property="og:type" content="article"><meta property="og:url" content="https://kalaqiae.com/post/android/android-note/"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-12-24T16:42:02+08:00"><meta property="article:modified_time" content="2024-12-24T16:42:02+08:00"><meta itemprop=name content="Android Note"><meta itemprop=description content="Android 四大组件

Activity

生命周期
启动模式（standard，singleTop，singleTask，singleInstance）
任务栈
启动方式：显式 Intent，隐式 Intent（Intent Filter，URL Scheme，跨应用场景用隐式），ARouter
PendingIntent
数据传递
startActivityForResult
启动一个 Activity 并等待结果。注意：startActivityForResult() 在 Android 11 及以上版本已被弃用，推荐使用 ActivityResultContracts 替代
Fragment

生命周期（onAttach，onCreate，onCreateView，onActivityCreated，onStart，onResume，onPause，onStop，onDestroyView，onDestroy，onDetach）
通信
DialogFragment()


onConfigurationChanged
onSaveInstanceState


"><meta itemprop=datePublished content="2024-12-24T16:42:02+08:00"><meta itemprop=dateModified content="2024-12-24T16:42:02+08:00"><meta itemprop=wordCount content="9731"><meta itemprop=keywords content="Android,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Android Note"><meta name=twitter:description content="Android 四大组件

Activity

生命周期
启动模式（standard，singleTop，singleTask，singleInstance）
任务栈
启动方式：显式 Intent，隐式 Intent（Intent Filter，URL Scheme，跨应用场景用隐式），ARouter
PendingIntent
数据传递
startActivityForResult
启动一个 Activity 并等待结果。注意：startActivityForResult() 在 Android 11 及以上版本已被弃用，推荐使用 ActivityResultContracts 替代
Fragment

生命周期（onAttach，onCreate，onCreateView，onActivityCreated，onStart，onResume，onPause，onStop，onDestroyView，onDestroy，onDetach）
通信
DialogFragment()


onConfigurationChanged
onSaveInstanceState


"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--><script data-ad-client=ca-pub-6216241935841265 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>Kalaqiae</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>首页</li></a><a href=/post/><li class=mobile-menu-item>归档</li></a><a href=/tags/><li class=mobile-menu-item>标签</li></a><a href=/categories/><li class=mobile-menu-item>分类</li></a><a href=/about/><li class=mobile-menu-item>关于</li></a><a href=/tools/><li class=mobile-menu-item>工具</li></a><a href=/games/><li class=mobile-menu-item>游戏</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>Kalaqiae</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>首页</a></li><li class=menu-item><a class=menu-item-link href=/post/>归档</a></li><li class=menu-item><a class=menu-item-link href=/tags/>标签</a></li><li class=menu-item><a class=menu-item-link href=/categories/>分类</a></li><li class=menu-item><a class=menu-item-link href=/about/>关于</a></li><li class=menu-item><a class=menu-item-link href=/tools/>工具</a></li><li class=menu-item><a class=menu-item-link href=/games/>游戏</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>Android Note</h1><div class=post-meta><span class=post-time>2024-12-24</span><div class=post-category><a href=/categories/android/>Android</a></div><span id=busuanzi_container_page_pv class=more-meta><span id=busuanzi_value_page_pv><img src=/img/spinner.svg alt=spinner.svg></span> 次阅读</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><ul><li><a href=#android-四大组件>Android 四大组件</a></li><li><a href=#ui-与交互>UI 与交互</a></li><li><a href=#性能优化>性能优化</a></li><li><a href=#线程>线程</a></li><li><a href=#数据存储>数据存储</a></li><li><a href=#网络与通信>网络与通信</a></li><li><a href=#设备与传感器>设备与传感器</a></li><li><a href=#权限与安全>权限与安全</a></li><li><a href=#资源管理与国际化>资源管理与国际化</a></li><li><a href=#应用架构>应用架构</a></li><li><a href=#设计模式>设计模式</a></li><li><a href=#打包与发布>打包与发布</a></li><li><a href=#开源库与工具>开源库与工具</a></li><li><a href=#android-系统启动过程>Android 系统启动过程</a></li><li><a href=#ndk>NDK</a></li><li><a href=#音视频>音视频</a></li><li><a href=#jetpack-compose>Jetpack Compose</a></li><li><a href=#jetpack>Jetpack</a></li><li><a href=#kotlin>Kotlin</a></li><li><a href=#flutter>Flutter</a></li><li><a href=#常见问题>常见问题</a></li><li><a href=#提问>提问</a></li></ul></li></ul></nav></div></div><div class=post-content><h2 id=android-四大组件>Android 四大组件</h2><ul><li><strong>Activity</strong><ul><li>生命周期</li><li>启动模式（standard，singleTop，singleTask，singleInstance）</li><li>任务栈</li><li>启动方式：显式 Intent，隐式 Intent（Intent Filter，URL Scheme，跨应用场景用隐式），ARouter</li><li>PendingIntent</li><li>数据传递</li><li>startActivityForResult
启动一个 Activity 并等待结果。注意：<code>startActivityForResult()</code> 在 Android 11 及以上版本已被弃用，推荐使用 <code>ActivityResultContracts</code> 替代</li><li>Fragment<ul><li>生命周期（onAttach，onCreate，onCreateView，onActivityCreated，onStart，onResume，onPause，onStop，onDestroyView，onDestroy，onDetach）</li><li>通信</li><li>DialogFragment()</li></ul></li><li>onConfigurationChanged</li><li>onSaveInstanceState</li></ul></li></ul><ul><li><strong>Service</strong><ul><li>启动服务（startService，bindService）</li><li>生命周期（onCreate，onStartCommand，onBind，onUnbind，onDestroy）</li><li>通信（Activity，IPC）</li><li>服务保活</li><li>前台服务（startForeground）</li><li>IntentService</li></ul></li><li><strong>BroadcastReceiver</strong><ul><li>类型（普通广播，有序广播，本地广播）</li><li>注册方式（静态注册，动态注册。 Android 8.0 及以上版本，需要动态注册）</li><li>发送和接收</li><li>常见的系统广播</li></ul></li><li><strong>ContentProvider</strong><ul><li>ContentProvider 是 Android 中用于在不同应用之间共享数据的机制。它允许应用访问另一个应用的数据，提供一种统一的接口，通过 URI 来操作不同数据源。常用于数据库、文件、共享的内容（如联系人、图片等）数据的访问</li><li>URI</li><li>MIME</li><li>主要方法(onCreate，query，insert，update，delete，getType)</li><li>在AndroidManifest.xml文件中的 application节点下使用标签注册时android:exported=&ldquo;false"时，不允许其他应用调用</li></ul></li></ul><h2 id=ui-与交互>UI 与交互</h2><ul><li><strong>View</strong><ul><li>自定义 View（一般继承 View 或已有控件如：TextView）</li><li>View 的绘制<ul><li>测量，布局，绘制</li></ul></li><li>View 的宽高获取<ul><li>view.getMeasureWidth() view.getMeasuredHeight()</li><li>ViewTreeObserver</li></ul></li><li>事件分发<ul><li>事件流<ul><li>事件分发：dispatchTouchEvent()</li><li>事件拦截：onInterceptTouchEvent()</li><li>事件处理：onTouchEvent()</li></ul></li><li>事件的传递顺序<ul><li>Activity -> ViewGroup -> View</li><li>ViewGroup -> 子 View</li><li>父控件优先：父控件先接收事件，决定是否继续传递给子控件</li></ul></li><li>拦截与处理<ul><li>dispatchTouchEvent()：分发触摸事件，判断是否继续向下传递</li><li>onInterceptTouchEvent()：拦截触摸事件，父控件可以选择拦截，决定是否传递给子控件</li><li>onTouchEvent()：最终的事件处理，子控件接收并处理事件</li></ul></li><li>ViewGroup中的事件分发</li><li>解决滑动冲突<ul><li>requestDisallowInterceptTouchEvent()：通知父控件不要拦截事件</li><li>onTouchEvent() 的返回值处理</li><li>onInterceptTouchEvent() 的实现</li></ul></li></ul></li></ul></li><li><strong>Widgets</strong><ul><li>Text Widgets<ul><li>TextView</li><li>EditText</li></ul></li><li>Button Widgets<ul><li>Button</li><li>CheckBox</li><li>RadioButton</li><li>Switch</li></ul></li><li>Image<ul><li>ImageView</li></ul></li><li>Container Widgets<ul><li>RecyclerView</li><li>ListView</li><li>ViewPager</li><li>CardView</li></ul></li><li>Progress Widgets<ul><li>ProgressBar</li><li>SeekBar</li></ul></li><li>Other Widgets<ul><li>Toast</li></ul></li></ul></li><li><strong>Layout</strong><ul><li>LinearLayout</li><li>RelativeLayout</li><li>ConstraintLayout</li><li>FrameLayout</li><li>ScrollView</li><li>HorizontalScrollView</li><li>GridLayout</li></ul></li><li><strong>Animation</strong><ul><li>View Animation<ul><li>Tween Animation（TranslateAnimation、RotateAnimation、ScaleAnimation、AlphaAnimation）</li><li>Frame Animation</li></ul></li><li>Property Animation<ul><li>ObjectAnimator（对任意属性进行动画）</li><li>ValueAnimator（基于值变化的动画，支持更多控制和时间插值）</li><li>AnimatorSet（组合多个动画的执行）</li></ul></li><li>Transition Animation</li><li>第三方（Lottie，PAG ）</li></ul></li><li><strong>屏幕适配</strong><ul><li>使用 dp 和 sp 单位</li><li>使用约束布局</li><li>使用百分比布局(PercentLayout)</li><li>使用自动缩放(AutoSizeText)</li><li>使用不同的布局文件</li><li>全面屏适配</li><li>第三方（AndroidAutoSize等）</li></ul></li><li><strong>通知</strong><ul><li>通知的组成部分</li><li>通知的渠道</li><li>通知优先级</li><li>通知类型</li><li>通知的操作</li><li>通知的权限</li></ul></li><li><strong>WebView</strong><ul><li>基本使用</li><li>与 JavaScript 交互<ul><li>Android 调用 JavaScript</li><li>JavaScript 调用 Android</li></ul></li><li>优化</li><li>第三方库<ul><li>腾讯 X5</li></ul></li></ul></li></ul><h2 id=性能优化>性能优化</h2><ul><li><strong>启动（冷启动，热启动）优化</strong><ul><li>启动流程</li><li>启动方式（使用singleTask、singleTop避免重复启动Activity）</li><li>统计启动时间</li><li>优化splash页</li><li>优化Activity</li></ul></li><li><strong>布局优化</strong><ul><li>减少嵌套</li><li>ViewStub include merge</li></ul></li><li><strong>内存优化</strong><ul><li>内存泄漏检测（LeakCanary，Android Studio Profiler）</li><li>内存泄漏常见类型<ul><li>Bitmap 未调用 recycle或内存溢出（Bitmap解码格式也可以优化，内存泄漏会导致内存溢出，内存溢出不一定是内存泄漏）</li><li>Context 引用不当</li><li>Handler 引用泄漏</li><li>静态变量持有引用</li><li>未关闭资源（如 Cursor、File、Network 等）</li></ul></li><li>GC<ul><li>减少对象创建频率，避免频繁 GC</li><li>内存管理（如 WeakReference）</li></ul></li></ul></li><li><strong>卡顿优化（布局，内存，线程等优化都和卡顿优化有关）</strong><ul><li>检测工具（Android Studio Profiler）</li><li>ANR</li></ul></li><li><strong>apk瘦身</strong><ul><li>ProGuard，精简资源（如图片格式WebP，无用资源），移除不必要的依赖</li></ul></li><li><strong>网络优化</strong><ul><li>减少请求次数，使用缓存</li><li>请求速度等监测（Android Studio ProfilerFiddler）</li></ul></li><li><strong>电量优化</strong><ul><li>后台任务优化（使用 JobScheduler、WorkManager 等智能调度后台任务）</li><li>避免频繁的 GPS 定位与传感器操作（使用适当的定位精度与更新频率）</li><li>高效使用广播与定时任务（使用合适的广播接收器（如 LocalBroadcast））</li></ul></li><li><strong>数据存储优化</strong><ul><li>使用合适的数据库结构（如 Room）</li><li>减少存储操作频率，合并多次操作</li></ul></li><li><strong>多线程与异步优化</strong><ul><li>避免频繁创建线程</li><li>&mldr;</li></ul></li></ul><h2 id=线程>线程</h2><ul><li><strong>主线程（UI线程）</strong></li><li><strong>子线程（处理耗时操作）</strong><ul><li>常见创建方式<ul><li>Thread</li><li>AsyncTask（已过时）</li><li>HandlerThread</li><li>线程池 (ExecutorService)</li><li>Kotlin 协程</li></ul></li></ul></li><li><strong>线程池（ExecutorService）</strong><ul><li>常见线程池<ul><li>FixedThreadPool（固定大小线程池）</li><li>CachedThreadPool（根据需要创建新线程，空闲线程会被回收）</li><li>SingleThreadExecutor（只有一个线程的线程池）</li><li>ScheduledThreadPoolExecutor（支持定时任务的线程池）</li></ul></li><li>核心参数<ul><li>corePoolSize (核心线程数)</li><li>maximumPoolSize (最大线程数)</li><li>keepAliveTime (线程空闲存活时间)</li><li>BlockingQueue (阻塞队列)</li></ul></li></ul></li><li><strong>线程间通信</strong><ul><li>Handler 机制：允许在不同线程之间传递消息和 Runnable 对象<ul><li>Looper：每个线程都有一个 Looper 对象，负责消息循环。主线程默认有 Looper</li><li>MessageQueue：存储消息队列</li><li>Handler.post(Runnable)：将 Runnable 投递到 Handler 所在的线程执行</li><li>Handler.sendMessage(Message)：发送消息</li></ul></li><li>runOnUiThread()：在 Activity 或 View 中提供的方法，允许在主线程上执行 Runnable。本质是 Handler 机制的封装</li><li>View.post(Runnable)：类似 runOnUiThread()</li><li>Kotlin 协程：通过 withContext(Dispatchers.Main) 切换到主线程</li><li>EventBus</li></ul></li><li><strong>线程同步与锁</strong><ul><li>synchronized 关键字</li><li>Lock 接口及其实现类（ReentrantLock、ReadWriteLock 等）</li><li>volatile 关键字（强调其只能保证可见性，不能保证原子性）</li><li>原子类（AtomicInteger、AtomicBoolean 等）</li><li>死锁：产生原因、避免方法</li></ul></li><li><strong>后台线程</strong><ul><li>IntentService（Android 11弃用，用 JobIntentService ， WorkManager 代替）</li><li>WorkManager</li></ul></li><li><strong>线程状态</strong><ul><li>New</li><li>Runnable</li><li>Blocked</li><li>Waiting</li><li>Timed Waiting</li><li>Terminated</li></ul></li></ul><h2 id=数据存储>数据存储</h2><ul><li><strong>内部存储</strong><ul><li>文件存储<ul><li>其他应用无法访问，无需权限</li><li>Context.getFilesDir()：获取应用私有文件目录。用于存储应用运行时生成或需要持久保存的文件，例如配置文件、日志文件、游戏存档等</li><li>Context.getCacheDir()：获取应用私有缓存目录。用于存储临时文件，例如网络请求的缓存数据、图片缓存等。系统可能会在存储空间不足时自动删除此目录下的文件</li></ul></li><li>SharedPreferences</li><li>MMKV（支持跨进程）</li></ul></li><li><strong>外部存储</strong><ul><li>应用专属的外部存储<ul><li>应用专属目录下的数据卸载应用时会被清除</li><li>不需要权限</li><li>使用 Context.getExternalFilesDir() 方法访问</li></ul></li><li>公共存储 (Shared Storage) (Android 10+)<ul><li>MediaStore API<ul><li>用于访问音频、视频、图片等媒体文件</li></ul></li><li>存储访问框架 (SAF)<ul><li>允许应用通过系统文件选择器访问特定文件或文件夹</li></ul></li></ul></li><li>权限<ul><li>在 Android 10 之前，访问外部存储通常需要申请 READ_EXTERNAL_STORAGE 和 WRITE_EXTERNAL_STORAGE 权限</li><li>Android 10 引入了分区存储规则 (Scoped Storage)</li><li>如果应用需要访问所有文件，需要申请 MANAGE_EXTERNAL_STORAGE 权限（Android 11 及以上）</li></ul></li></ul></li><li><strong>数据库存储</strong><ul><li>SQLite<ul><li>数据库创建和管理（SQLiteOpenHelper）</li></ul></li><li>Room Database</li></ul></li><li><strong>网络存储</strong><ul><li>网络缓存</li><li>数据同步与备份</li></ul></li></ul><h2 id=网络与通信>网络与通信</h2><ul><li><strong>网络请求</strong><ul><li>HTTP协议</li><li>主流框架<ul><li>Retrofit</li><li>OkHttp</li></ul></li></ul></li><li><strong>长连接与实时通信</strong><ul><li>Socket（基于 TCP/UDP）<ul><li>TCP (Transmission Control Protocol)：面向连接的可靠传输协议，提供有序、无差错的数据传输。适用于对数据完整性要求高的场景，如文件传输</li><li>UDP (User Datagram Protocol)：无连接的不可靠传输协议，传输速度快，但可能丢包。适用于对实时性要求高的场景，如视频通话、游戏</li></ul></li><li>WebSocket (基于 HTTP/TCP，双向通信)<ul><li>在建立连接后，数据可以以帧的形式双向传输，开销比 HTTP 小，更适合实时性要求高的应用，例如在线聊天、实时游戏等</li></ul></li></ul></li><li>其他实时通信技术<ul><li>Server-Sent Events (SSE)：服务器单向向客户端推送数据。</li><li>MQTT：轻量级的消息队列协议，适用于物联网等场景</li></ul></li><li><strong>IPC（进程间通信）</strong><ul><li>Binder<ul><li>基于 C/S 架构，具有高性能、高安全性的特点</li><li>AIDL、ContentProvider 等都基于 Binder 实现</li><li>适用于系统服务开发、性能敏感、灵活性需求高的场景，支持同一应用内简单通信，不涉及复杂多线程时性能优秀</li></ul></li><li>AIDL<ul><li>适合需要复杂、多线程支持的进程间通信场景</li></ul></li><li>ContentProvider<ul><li>主要用在跨进程的数据访问，如读取联系人、访问系统设置等</li></ul></li><li>Messenger<ul><li>基于 Handler 和 Message 实现的轻量级 IPC 机制</li><li>使用简单，但只能进行单向通信，且效率不如 Binder</li></ul></li><li>Broadcast<ul><li>适合一对多通信场景</li></ul></li><li>文件<ul><li>适合低频的数据交换场景</li></ul></li><li>Socket<ul><li>适合跨设备或跨网络的进程间通信</li></ul></li></ul></li></ul><h2 id=设备与传感器>设备与传感器</h2><ul><li><strong>蓝牙</strong></li><li><strong>wifi</strong></li><li><strong>定位</strong></li><li><strong>NFC</strong></li><li><strong>陀螺仪</strong></li><li><strong>加速度</strong></li><li>&mldr;</li></ul><h2 id=权限与安全>权限与安全</h2><ul><li><strong>权限</strong><ul><li>权限分类<ul><li>普通权限：无需用户手动授权，如：ACCESS_NETWORK_STATE (访问网络状态)</li><li>危险权限：涉及用户隐私或设备安全，需要用户在运行时手动授权。如：CAMERA (使用相机)、READ_CONTACTS (读取联系人)</li><li>特殊权限：需用户明确授予，通常需要用户在系统设置中手动开启。如：SYSTEM_ALERT_WINDOW (在其他应用上显示窗口)、WRITE_SETTINGS (修改系统设置)</li></ul></li><li>权限申请<ul><li>静态声明（AndroidManifest.xml）</li><li>动态请求（运行时权限）</li></ul></li><li>权限撤销<ul><li>用户手动撤销</li><li>系统自动撤销</li></ul></li></ul></li><li><strong>安全机制</strong><ul><li>应用签名</li><li>沙箱机制 (Sandbox Mechanism)</li><li>Google Play 保护机制</li><li>SELinux (Security-Enhanced Linux)：SELinux 是 Android 系统中使用的强制访问控制 (MAC) 安全机制，它进一步限制了应用和系统进程的权限，提高了系统的安全性</li><li>应用隔离</li></ul></li><li><strong>数据加密</strong><ul><li>SharedPreferences 加密（EncryptedSharedPreferences ）</li><li>数据库加密（SQLCipher）</li><li>文件加密（EncryptedFile）</li><li>全盘加密</li><li>密钥管理 (Key Management) (如：KeyStore)</li><li>数据传输加密 (HTTPS)</li></ul></li><li><strong>逆向与防护</strong><ul><li>Apk反编译<ul><li>工具：apktool, dex2jar, jd-gui</li></ul></li><li>代码混淆<ul><li>工具：ProGuard, R8</li></ul></li><li>加固</li><li>反调试</li><li>防篡改</li><li>完整性校验</li><li>第三方库的安全性</li></ul></li><li><strong>用户隐私保护</strong><ul><li>隐私政策</li><li>数据收集和权限最小化</li><li>数据透明度</li></ul></li></ul><h2 id=资源管理与国际化>资源管理与国际化</h2><ul><li><strong>资源类型</strong><ul><li>布局<ul><li>layout-swxxdp: 针对不同屏幕宽度 (smallest width) 的布局，例如 layout-sw600dp/ (平板)</li><li>layout-land：横屏布局</li><li>layout-xx：特定语言环境的布局文件</li></ul></li><li>字符串<ul><li>values-xx/strings.xml(如 values-en)</li><li>values-xx-rYY/strings.xml (区域化语言环境，如 values-en-rUS)</li></ul></li><li>图片<ul><li>drawable-xx：针对不同分辨率的图像资源，例如 drawable-hdpi/, drawable-xhdpi/</li><li>矢量图，.9，WebP</li></ul></li><li>启动图标<ul><li>mipmap</li></ul></li><li>颜色<ul><li>values-night/colors.xml：夜间模式下的颜色配置</li></ul></li><li>样式<ul><li>values-night/styles.xml: 夜间模式下的样式</li></ul></li><li>尺寸</li><li>XML 资源<ul><li>网络安全配置（network-security-config.xml）</li><li>首选项 (Preferences): preferences.xml</li></ul></li><li>动画<ul><li>anim: 存放动画资源</li></ul></li><li>原始资源<ul><li>raw: 存放原始文件，如音频、视频等</li></ul></li></ul></li><li><strong>资源限定符</strong><ul><li>屏幕密度 (Screen Density): ldpi, mdpi, hdpi, xhdpi, xxhdpi, xxxhdpi, anydpi, nodpi</li><li>语言和地区 (Locale): 语言代码、语言代码-r地区代码</li><li>系统版本：vXX</li><li>&mldr;</li></ul></li><li><strong>国际化 (i18n)与本地化 (l10n)</strong><ul><li>字符串国际化<ul><li>使用 <code>String.format()</code> 方法进行复杂的字符串格式化</li><li>复数形式 (Plurals)：使用 <code>&lt;plurals></code> 标签处理不同数量的复数形式</li></ul></li><li>图标和图像</li><li>时间日期,数字和货币(DateFormat,NumberFormat,Currency)</li><li>RTL布局（支持阿拉伯语、希伯来语等 RTL 语言）<ul><li>使用 <code>android:supportsRtl="true"</code> 在 <code>AndroidManifest.xml</code> 中启用 RTL 支持</li><li>使用 Viewpager2</li><li>使用Android studio自带的工具适配(可以批量修改marginLeft为marginStart等)</li><li>&mldr;</li></ul></li></ul></li></ul><h2 id=应用架构>应用架构</h2><ul><li><strong>架构模式</strong><ul><li>MVC<ul><li>优点： 简单易懂，易于上手</li><li>缺点： View层承担了过多的职责，导致难以维护和测试；Controller层也容易变得臃肿。在Android中，Activity承担了Controller的角色，使得Activity过于庞大</li></ul></li><li>MVP<ul><li>优点： View层只负责UI展示，Presenter层处理业务逻辑，解耦更加彻底，易于测试</li><li>缺点： Presenter层会变得比较重，接口定义较多</li></ul></li><li>MVVM<ul><li>优点： 通过Data Binding或类似机制，进一步减少了View层的代码，提高了开发效率。ViewModel负责处理UI逻辑和数据转换，更专注于View的状态管理</li><li>缺点： 对于简单的UI，使用MVVM可能会显得过于复杂</li></ul></li><li>MVI<ul><li>优点： 强调单向数据流，状态管理更加清晰可控，易于调试和测试，适合复杂的状态管理场景</li><li>缺点： 学习曲线相对较高，需要引入额外的概念和组件</li></ul></li></ul></li><li><strong>架构原则（SOLID + 其他）</strong><ul><li>单一职责原则（SRP，每个类应该有且只有一个职责，避免多重职责带来的复杂性）</li><li>开放封闭原则（OCP，类应该对扩展开放，对修改封闭，支持功能扩展而不修改原有代码）</li><li>里氏替换原则（LSP，子类应该可以替换父类，并且父类的功能不应该被破坏）</li><li>接口隔离原则（ISP，不要强迫客户端依赖它们不使用的接口，接口应该小而专注）</li><li>依赖倒置原则（DIP，高层模块不应该依赖低层模块，二者都应该依赖抽象；抽象不应该依赖细节，细节应该依赖抽象）</li><li>DRY（Don&rsquo;t Repeat Yourself）</li><li>KISS（Keep It Simple, Stupid）</li><li>YAGNI（You Ain&rsquo;t Gonna Need It）</li></ul></li><li><strong>架构方法</strong><ul><li>组件化</li><li>模块化/插件化</li><li>Clean Architecture</li></ul></li><li><strong>架构组件和技术</strong><ul><li>ViewModel</li><li>LiveData</li><li>Room</li><li>WorkManager</li><li>Dagger/Hilt/Koin</li><li>&mldr;</li></ul></li></ul><h2 id=设计模式>设计模式</h2><ul><li><p>创建型模式 (Creational Patterns)：关注对象创建的机制，提供多种创建对象的方式，提高代码的灵活性和复用性</p><ul><li>单例模式 (Singleton)<ul><li>保证一个类只有一个实例，并提供全局访问点</li><li>目的：控制实例数量，节约资源，避免资源冲突</li><li>应用场景：全局配置对象、数据库连接池、日志管理器</li></ul></li><li>工厂模式 (Factory)<ul><li>定义一个创建对象的接口，但由子类决定实例化哪一个类</li><li>目的：解耦对象的创建和使用</li><li>应用场景：多个类共享同一个接口，具体类型通过工厂来决定</li><li>分类: 简单工厂（非严格的设计模式）、工厂方法、抽象工厂</li></ul></li><li>抽象工厂模式 (Abstract Factory)<ul><li>提供创建一系列相关或相互依赖对象的接口，而无需指定具体类</li><li>应用场景：需要创建多个产品族的对象（与工厂方法区别：工厂方法针对单一产品等级结构，抽象工厂针对多个产品等级结构。）</li></ul></li><li>建造者模式 (Builder)<ul><li>通过一步步构建复杂对象，避免构造函数过多参数</li><li>应用场景：需要构建复杂对象的场景，如多步骤的 UI 界面初始化</li></ul></li><li>原型模式 (Prototype)：通过复制现有实例来创建新的对象，避免重复的初始化工作<ul><li>通过复制现有实例来创建新的对象</li><li>应用场景：创建重复对象时，性能需求较高</li></ul></li></ul></li><li><p>结构型模式 (Structural Patterns)：关注类和对象的组合方式，通过组合形成更大的结构</p><ul><li>适配器模式 (Adapter)<ul><li>使得两个不兼容的接口能够协同工作</li><li>应用场景：需要使用第三方库或遗留代码，但接口不兼容，例如将第三方支付接口适配到现有系统</li></ul></li><li>装饰器模式 (Decorator)<ul><li>动态地给一个对象添加额外的职责</li><li>应用场景：功能扩展需要时，不修改原有代码</li></ul></li><li>代理模式 (Proxy)<ul><li>通过代理对象控制对原对象的访问</li><li>应用场景：延迟加载、权限控制、远程访问等</li></ul></li><li>外观模式 (Facade)<ul><li>提供一个统一的接口，简化子系统的使用</li><li>应用场景：简化系统接口，让外部代码与系统交互更简单</li></ul></li><li>组合模式 (Composite)<ul><li>允许将对象组合成树形结构来表示部分和整体的层次关系</li><li>应用场景：树形结构的对象处理，如文件系统</li></ul></li><li>享元模式 (Flyweight)<ul><li>用共享对象来支持大量细粒度的对象</li><li>应用场景：高效管理大量对象，节约内存资源（如图形对象的缓存）</li></ul></li></ul></li><li><p>行为型模式 (Behavioral Patterns)：关注对象之间的责任分配和算法</p><ul><li>观察者模式 (Observer)<ul><li>当一个对象的状态发生变化时，所有依赖它的对象都会被通知并更新</li><li>应用场景：事件监听、数据变化通知</li></ul></li><li>策略模式 (Strategy)<ul><li>定义一系列算法，将每个算法封装起来，并使它们可以互换</li><li>应用场景：多种行为选择的情况，如排序算法选择</li></ul></li><li>模板方法模式 (Template Method)<ul><li>定义一个操作中的算法骨架，将一些步骤的实现延迟到子类</li><li>应用场景：处理具有固定步骤的流程，但允许子类实现某些步骤</li></ul></li><li>责任链模式 (Chain of Responsibility)<ul><li>使多个对象有机会处理请求，从而避免请求的发送者与接收者之间的耦合关系</li><li>应用场景：日志处理、权限检查等链式处理需求</li></ul></li><li>命令模式 (Command)<ul><li>将请求封装为一个对象，从而使用户可以通过不同的请求来参数化客户端</li><li>应用场景：操作历史、撤销操作、事务管理</li></ul></li><li>状态模式 (State)<ul><li>允许一个对象在其内部状态改变时改变它的行为</li><li>应用场景：对象在不同状态下有不同的表现，如游戏角色的不同状态（攻击、休息、移动</li></ul></li><li>迭代器模式 (Iterator)<ul><li>提供一种方法顺序访问一个集合对象中的各个元素，而又不暴露该对象的内部结构</li><li>应用场景：遍历集合对象</li></ul></li><li>中介者模式 (Mediator)<ul><li>用一个中介对象来封装一系列的对象交互，使得对象之间不直接相互引用</li><li>应用场景：多个组件协作的场景，减少组件之间的耦合</li></ul></li><li>备忘录模式 (Memento)<ul><li>在不暴露对象实现细节的情况下，捕获一个对象的内部状态，并在以后将对象恢复到原先的状态</li><li>应用场景：游戏存档、撤销功能</li></ul></li><li>访问者模式 (Visitor)<ul><li>允许在不修改元素类的前提下定义作用于这些元素的新操作</li><li>应用场景：跨越多种对象的操作，如集合中多种对象的处理</li></ul></li><li>解释器模式 (Interpreter)<ul><li>设计一个解释器，用于解释特定语言的语法规则</li><li>应用场景：编译器、查询解析等场景</li></ul></li></ul></li></ul><h2 id=打包与发布>打包与发布</h2><ul><li><strong>应用打包</strong><ul><li>打包格式<ul><li>APK</li><li>AAB (Android App Bundle)：Google 推荐的发布格式，用于动态交付</li></ul></li><li>多渠道打包<ul><li>使用 Gradle Product Flavors</li><li>第三方工具（或自己写Python脚本）</li></ul></li><li>应用签名</li></ul></li><li><strong>版本适配</strong><ul><li>目标 SDK 版本与兼容性处理</li><li>各版本特性差异<ul><li>Android 6.0<ul><li>危险权限需要在运行时动态请求用户授权</li></ul></li><li>Android 7.0<ul><li>禁止使用 file:// URI 共享文件，必须使用 content:// URI 和 FileProvider</li></ul></li><li>Android 8.0<ul><li>对后台服务和广播接收器施加了限制</li><li>安装未知应用权限：安装未知来源应用的权限变更，需要单独授权</li></ul></li><li>Android 9.0<ul><li>使用 HTTPS 进行网络请求</li><li>使用 DisplayCutout API 来避免内容被刘海遮挡</li></ul></li><li>Android 10<ul><li>引入分区存储，应用只能访问自身的文件和用户授权的目录</li><li>Activity 后台启动限制,限制应用在后台启动 Activity</li></ul></li><li>Android 11<ul><li>限制应用查看其他已安装应用的能力，在 AndroidManifest.xml 文件中声明应用需要访问的软件包</li></ul></li><li>Android 12<ul><li>引入新的启动画面，可以使用SplashScreen API实现新的启动画面效果</li></ul></li><li>Android 13<ul><li>应用需要请求发送通知的权限</li><li>提供了新的照片选择器</li></ul></li><li>Android 14<ul><li>适配新的媒体权限申请流程： 处理用户只授予部分访问权限的情况</li></ul></li></ul></li></ul></li><li><strong>发布与更新</strong><ul><li>Google Play等应用商店的发布</li><li>更新策略与版本管理<ul><li>版本号，版本名称</li><li>强制更新</li><li>静默更新</li><li>增量更新</li><li>应用内更新</li><li>热更新</li></ul></li><li>应用分发平台（蒲公英，fir.im等）</li></ul></li></ul><h2 id=开源库与工具>开源库与工具</h2><ul><li><strong>UI 库</strong><ul><li>Glide</li><li>Jetpack Compose</li><li>MPAndroidChart</li><li>Material Components for Android</li></ul></li><li><strong>网络库</strong><ul><li>Retrofit</li><li>OkHttp</li></ul></li><li><strong>数据库和存储库</strong><ul><li>Room</li><li>MMKV</li><li>DataStore</li></ul></li><li><strong>测试</strong><ul><li>JUnit</li><li>Espresso(UI自动化测试)</li><li>Mockito (Java Mock 框架)</li><li>MockK (Kotlin Mock 框架，更适合 Kotlin 项目)</li></ul></li><li><strong>依赖注入</strong><ul><li>Dagger/Hilt</li><li>Koin</li></ul></li><li><strong>响应式编程与异步处理</strong><ul><li>Rxjava</li><li>Kotlin Coroutines</li></ul></li><li><strong>其他</strong><ul><li>EventBus（事件总线）</li><li>Tinker</li><li>LeakCanary</li></ul></li></ul><h2 id=android-系统启动过程>Android 系统启动过程</h2><ul><li><strong>开机引导 (Boot Process)</strong><ul><li><strong>硬件初始化 (Bootloader)</strong><ul><li>开机时，首先加载 Bootloader。</li><li>Bootloader 负责硬件初始化(例如内存、时钟、外设等)、检查系统分区、加载内核</li><li>启动模式：<ul><li>正常启动 (Normal Boot)：加载并启动内核</li><li>Fastboot (用于刷机、解锁等操作等)</li><li>Recovery Mode (用于系统恢复、更新等操作)</li></ul></li></ul></li><li><strong>加载并启动内核 (Linux Kernel)</strong><ul><li>Bootloader 将内核映像(kernel image)加载到内存中并启动</li><li>内核初始化系统资源，如 CPU、内存、驱动程序、硬件等</li><li>启动 init 进程，是 Android 系统中的第一个用户空间进程，它负责启动其他进程</li></ul></li></ul></li><li><strong>init 进程启动(PID=1）</strong><ul><li><strong>启动 init.rc 脚本</strong><ul><li>读取并解析 <code>/init.rc</code> 脚本（以及 <code>/system/etc/init</code> 目录下的其他 init 脚本）</li><li>执行脚本中的命令 (actions) 和启动服务 (services)</li><li>脚本中定义了各种 actions 和 services，包括：<ul><li>设置系统属性 (setprop)</li><li>挂载文件系统 (mount)</li><li>启动守护进程 (service)</li></ul></li><li>启动 Zygote 进程</li><li>启动 System Server 进程</li></ul></li></ul></li><li><strong>Zygote 进程 (所有应用进程的父进程)</strong><ul><li>创建 Dalvik/ART 虚拟机实例，为后续的应用程序提供运行环境</li><li>注册 JNI 方法</li><li>预加载类和资源</li><li>监听 AMS (Activity Manager Service) 的请求</li><li>fork 出新的应用进程</li></ul></li><li><strong>SystemServer 进程 (系统服务进程)</strong><ul><li>启动各种系统服务<ul><li>AMS (Activity Manager Service):管理 Activity 的生命周期、进程调度等</li><li>PMS (Package Manager Service):管理应用程序的安装、卸载、更新等</li><li>WMS (Window Manager Service)：管理窗口的显示、布局等</li><li>其他重要服务：InputManagerService、WindowManagerService、PowerManagerService 等</li></ul></li></ul></li><li><strong>Launcher 启动</strong><ul><li>Launcher 作为一个普通的应用程序启动</li><li>加载并显示已安装的应用程序图标列表</li></ul></li><li><strong>应用启动</strong><ul><li>用户点击应用图标</li><li>Launcher 向 AMS 发送启动 Activity 的请求</li><li>AMS 检查应用进程是否存在<ul><li>如果不存在，则请求 Zygote fork 出新的进程</li><li>如果存在，则直接启动 Activity</li></ul></li></ul></li><li><strong>关键进程关系</strong><ul><li><strong>init</strong> 是所有用户空间进程的祖先进程</li><li><strong>Zygote</strong> 是所有 Android 应用进程的父进程</li><li><strong>SystemServer</strong> 进程包含许多重要的系统服务</li></ul></li></ul><h2 id=ndk>NDK</h2><ul><li><strong>NDK (Native Development Kit)作用</strong><ul><li>性能密集型任务 (游戏, 音视频处理, 图像处理)</li><li>访问硬件 (设备驱动程序开发。底层硬件控制：传感器、摄像头、蓝牙、Wi-Fi 等)</li><li>代码复用 (移植现有 C/C++ 库)</li><li>代码保护 (将核心逻辑放在 Native 层)</li></ul></li><li><strong>NDK 开发环境搭建</strong><ul><li>Android Studio 配置<ul><li>安装 NDK 和 CMake</li><li>配置 <code>local.properties</code> 文件 (ndk.dir, cmake.dir)</li></ul></li></ul></li><li><strong>构建系统</strong><ul><li>CMake (推荐)<ul><li><code>CMakeLists.txt</code> 文件 (指定源文件, 库, 编译选项)</li><li><code>build.gradle</code> 文件配置 (指定 CMakeLists.txt 路径)</li></ul></li><li>ndk-build (旧版本，逐渐弃用)</li></ul></li><li><strong>NDK 开发流程</strong><ul><li>创建 Native 方法 (JNI)</li><li>C/C++ 层实现 Native 方法 (JNI)<ul><li>JNI 函数命名规则</li><li>JNI 数据类型与 Java 数据类型的映射</li><li>JNI 方法签名</li><li>JNIEnv 接口</li></ul></li><li>编译生成 Native 库(.so 文件)</li><li>加载 Native 库：使用 System.loadLibrary() 或 System.load() 加载 .so 文件</li><li>使用LLDB调试器</li></ul></li><li><strong>JNI (Java Native Interface)</strong><ul><li>JNI 数据类型</li><li>JNI 方法</li><li>JNI 字符串处理</li><li>JNI 数组处理</li><li>JNI 对象引用</li></ul></li><li><strong>其他</strong><ul><li>常用库（FFmpeg，OpenCV，OpenGL 等）</li><li>减少 JNI 调用次数：避免频繁的 Java 和 Native 代码之间的切换，以提高性能</li><li>合理使用 JNI 引用：避免内存泄漏</li><li>线程安全</li><li>异常处理：在 Native 代码中处理异常并传递回 Java 层</li><li>ABI 管理：支持不同的 CPU 架构（armeabi-v7a, arm64-v8a, x86, x86_64 等</li></ul></li></ul><h2 id=音视频>音视频</h2><ul><li><strong>音频播放与录制</strong><ul><li>MediaPlayer（播放音频/视频）</li><li>AudioRecord（录音）</li><li>ExoPlayer（高效的多媒体播放器）</li></ul></li><li><strong>视频播放与录制</strong><ul><li>Camera2 API（视频录制与拍照）</li><li>VideoView</li><li>SurfaceView</li></ul></li><li><strong>音视频编码与解码</strong><ul><li>FFmpeg（音视频转码与流媒体处理）</li><li>H.264、AAC编码与解码</li></ul></li><li><strong>实时音视频</strong><ul><li>WebRTC（实时音视频通信）</li><li>RTSP流媒体协议</li></ul></li><li><strong>音频特效与处理</strong><ul><li>OpenSL ES（音频处理）</li><li>AudioTrack（音频播放）</li></ul></li><li><strong>流媒体与直播</strong><ul><li>RTMP</li><li>HLS</li><li>直播架构</li></ul></li></ul><h2 id=jetpack-compose>Jetpack Compose</h2><ul><li>基础概念<ul><li>Composable 函数<ul><li>@Composable 注解</li><li>重组 (Recomposition)<ul><li>重组的触发条件</li><li>避免不必要的重组 (性能优化)</li></ul></li><li>副作用 (Side Effects)<ul><li><code>LaunchedEffect</code></li><li><code>rememberCoroutineScope</code></li><li><code>DisposableEffect</code></li><li><code>SideEffect</code></li><li><code>produceState</code></li></ul></li><li>组合本地 (CompositionLocal)</li></ul></li><li>状态 (State)<ul><li>不可变性 (Immutability)</li><li>状态提升 (State Hoisting)</li><li>remember</li><li>rememberSaveable</li><li>mutableStateOf</li><li>State&lt;T></li><li>SnapshotStateList/Map</li></ul></li><li>修饰符 (Modifiers)<ul><li>布局修饰符 (Size、Padding、Offset、fillMaxWidth/Height、weight 等)</li><li>绘制修饰符 (Background、Border、Clip、graphicsLayer 等)</li><li>输入修饰符 (Clickable、PointerInput、focusable 等)</li><li>约束修饰符 (constrainAs、linkTo 等，用于 ConstraintLayout)</li><li>自定义修饰符</li></ul></li><li>生命周期 (Lifecycle)<ul><li>Activity/Fragment 生命周期与 Compose 的关系</li><li>rememberSaveable 的工作原理</li></ul></li><li>布局 (Layout)<ul><li>常用布局组件 (Column、Row、Box、LazyColumn、LazyRow、LazyVerticalGrid、LazyHorizontalGrid)</li><li>ConstraintLayout</li><li>自定义布局</li><li>测量 (Measure) 和 布局 (Layout) 过程</li></ul></li></ul></li><li>组件 (Components)<ul><li>基础组件 (Text、Button、Image、Icon、TextField、OutlinedTextField、Checkbox、RadioButton、Switch、Slider、Divider 等)</li><li>列表和网格 (LazyColumn、LazyRow、LazyVerticalGrid、LazyHorizontalGrid)</li><li>导航 (Navigation)<ul><li>Navigation Component</li><li>导航图 (Navigation Graph)</li><li>路由 (Routes)</li><li>传递参数</li><li>深层链接 (Deep Links)</li></ul></li><li>对话框 (Dialog) 和 底部表单 (BottomSheet)</li><li>脚手架 (Scaffold) 和 顶部应用栏 (TopAppBar)</li><li>动画 (Animation)<ul><li>状态动画 (State-based Animations): <code>animate*AsState</code></li><li>可见性动画 (Visibility Animations): <code>AnimatedVisibility</code></li><li>过渡动画 (Transition Animations): <code>updateTransition</code></li><li>无限动画 (Infinite Animations): <code>rememberInfiniteTransition</code></li><li>动画规范 (AnimationSpec): <code>tween</code>, <code>spring</code>, <code>keyframes</code></li><li>手势动画 (Gesture Animations)</li></ul></li></ul></li><li>状态管理 (State Management)<ul><li>ViewModel</li><li>StateFlow、LiveData、Flow</li><li>UI 状态 (UI State) 的定义和管理</li></ul></li><li>主题与样式 (Theme and Styling)<ul><li>MaterialTheme</li><li>Color、Typography、Shapes</li><li>自定义主题</li><li>系统 UI 控制 (System UI Controller) (例如：状态栏颜色)</li><li>暗黑模式 (Dark Mode) 支持</li></ul></li><li>性能优化 (Performance Optimization)<ul><li>避免不必要的重组</li><li>使用 key 稳定列表项</li><li>延迟组合 (Lazy Composition) 的优化</li><li>减少对象分配</li><li>使用 remember 和 derivedStateOf
性能分析工具 (Profiler)</li></ul></li><li>与 View 系统的互操作 (Interoperability with View System)<ul><li>AndroidView</li><li>ComposeView</li></ul></li></ul><h2 id=jetpack>Jetpack</h2><h2 id=kotlin>Kotlin</h2><h2 id=flutter>Flutter</h2><h2 id=常见问题>常见问题</h2><ul><li>遇到的难题</li><li>源码</li><li>Handler</li><li>事件分发</li><li>优化</li><li>热门技术</li><li>内存泄漏</li><li>Activity相关</li></ul><h2 id=提问>提问</h2><ul><li>技术栈</li><li>未来的技术方向和规划是什么</li><li>岗位是扩招还是人员流失</li><li>公司的核心产品或项目目前面临的最大技术挑战</li><li>项目开发周期是多长？团队对交付速度和质量的平衡是如何处理的</li><li>公司在行业中的竞争优势主要体现在哪些方面</li><li>工作具体需要做什么</li></ul><p><a href=https://developer.android.com/reference/android/app/Activity>在 Android Developer 的 reference 路径下查看 Android 的 Activity</a><br>这里以 Activity 为例子，还可以直接通过 Package 或者 Class 来检索 Android 相关的类</p><p><a href=https://developer.android.com/guide>在 Android Developer 的 guide</a><br>可以了解 AndroidManifest ，权限，资源等</p></div><footer class=post-footer><nav class=post-nav><a class=next href=/post/ios/swift/><span class="next-text nav-default">Swift</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div><script src=https://utteranc.es/client.js repo=kalaqiae/kalaqiae.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script><noscript>Please enable JavaScript to view the <a href=https://github.com/utterance>comments powered by utterances.</a></noscript></div></main><footer id=footer class=footer><div class=social-links></div><div class=copyright><span class=power-by></span><span class=theme-info></span><div class=busuanzi-footer></div><span class=copyright-year>&copy;
2025
<span>|</span>
<span>Kalaqiae</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js></script>
<script type=text/javascript src=https://cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js></script>
<script src=https://eqcn.ajz.miesnfu.com/wp-content/plugins/wp-3d-pony/live2dw/lib/L2Dwidget.min.js></script>
<script>var jsonModel=["https://unpkg.com/live2d-widget-model-shizuku@1.0.5/assets/shizuku.model.json","https://unpkg.com/live2d-widget-model-hijiki@1.0.5/assets/hijiki.model.json"];L2Dwidget.init({model:{jsonPath:jsonModel[Math.floor(Math.random()*jsonModel.length)],scale:1},display:{position:"left",width:66,height:90,hOffset:10,vOffset:0},mobile:{show:!1}})</script></body></html>