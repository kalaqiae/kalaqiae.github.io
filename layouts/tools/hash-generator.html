{{ define "title" }}å“ˆå¸Œå€¼ç”Ÿæˆå™¨ - {{ .Site.Title }}{{ end }}

{{ define "main" }}
<div class="tool-container">
    <div class="card-content">
        <h1 class="text-3xl font-bold mb-6 text-gray-800 flex items-center">
            <svg class="w-6 h-6 mr-3 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                xmlns="http://www.w3.org/2000/svg">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z">
                </path>
            </svg>
            å“ˆå¸Œå€¼ç”Ÿæˆå™¨ (MD5 / SHA)
        </h1>

        <!-- é”™è¯¯å’Œæ¶ˆæ¯æç¤ºåŒº -->
        <div id="messageBox" class="message-box"></div>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
            <!-- å·¦ä¾§ï¼šè¾“å…¥åŒº -->
            <div class="md:col-span-1">
                <label for="inputArea" class="block text-lg font-semibold mb-2 text-gray-700">è¾“å…¥æ–‡æœ¬:</label>
                <textarea id="inputArea" placeholder="åœ¨æ­¤è¾“å…¥éœ€è¦è®¡ç®—å“ˆå¸Œçš„æ–‡æœ¬..." autofocus></textarea>
                <div class="flex justify-between mt-2 text-sm text-gray-500">
                    <span>å½“å‰è¾“å…¥é•¿åº¦: <span id="inputLength">0</span> å­—ç¬¦</span>
                    <span id="calculationStatus" class="hidden">ğŸ”„ è®¡ç®—ä¸­...</span>
                </div>
                <button onclick="clearAll()"
                    class="tool-button w-full mt-4 bg-gray-200 text-gray-800 hover:bg-gray-300">
                    ğŸ§¹ æ¸…ç©ºè¾“å…¥
                </button>
            </div>

            <!-- å³ä¾§ï¼šè¾“å‡ºåŒº -->
            <div class="md:col-span-2">
                <label class="block text-lg font-semibold mb-2 text-gray-700">å“ˆå¸Œè®¡ç®—ç»“æœ:</label>

                <div id="outputContainer" class="space-y-3">
                    <!-- MD5 -->
                    <div class="hash-result">
                        <span class="hash-label">MD5 (32):</span>
                        <input type="text" id="hashMD5" readonly placeholder="è¾“å…¥æ–‡æœ¬åè‡ªåŠ¨è®¡ç®—">
                        <button onclick="copyHash('hashMD5')" class="copy-button">ğŸ“‹</button>
                    </div>

                    <!-- SHA-1 -->
                    <div class="hash-result">
                        <span class="hash-label">SHA-1 (40):</span>
                        <input type="text" id="hashSHA1" readonly placeholder="è¾“å…¥æ–‡æœ¬åè‡ªåŠ¨è®¡ç®—">
                        <button onclick="copyHash('hashSHA1')" class="copy-button">ğŸ“‹</button>
                    </div>

                    <!-- SHA-256 -->
                    <div class="hash-result">
                        <span class="hash-label">SHA-256 (64):</span>
                        <input type="text" id="hashSHA256" readonly placeholder="è¾“å…¥æ–‡æœ¬åè‡ªåŠ¨è®¡ç®—">
                        <button onclick="copyHash('hashSHA256')" class="copy-button">ğŸ“‹</button>
                    </div>

                    <!-- SHA-512 -->
                    <div class="hash-result">
                        <span class="hash-label">SHA-512 (128):</span>
                        <input type="text" id="hashSHA512" readonly placeholder="è¾“å…¥æ–‡æœ¬åè‡ªåŠ¨è®¡ç®—">
                        <button onclick="copyHash('hashSHA512')" class="copy-button">ğŸ“‹</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<style>
    .tool-container {
        max-width: 1000px;
        margin: 40px auto;
        padding: 20px;
    }

    .card-content {
        background-color: var(--card-background-base);
        padding: 1.5rem;
        border-radius: var(--border-radius);
        box-shadow: 0 8px 15px rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(5px);
        border: 1px solid #E0E0E0;
    }

    /* æ–‡æœ¬è¾“å…¥æ¡†æ ·å¼ */
    textarea {
        width: 100%;
        height: 250px;
        padding: 1rem;
        border: 2px solid #E0E0E0;
        border-radius: var(--border-radius);
        font-family: 'Consolas', 'Courier New', monospace;
        font-size: 0.95rem;
        resize: vertical;
        outline: none;
        transition: border-color 0.2s;
        background-color: #F8F9FA;
    }

    textarea:focus {
        border-color: var(--primary-color);
        box-shadow: 0 0 0 3px rgba(30, 136, 229, 0.2);
    }

    .tool-button {
        padding: 0.75rem 1.5rem;
        border-radius: 0.5rem;
        font-weight: 600;
        transition: all 0.2s;
        border: none;
        cursor: pointer;
    }

    .tool-button:hover {
        box-shadow: 0 4px 8px rgba(30, 136, 229, 0.4);
        transform: translateY(-1px);
    }

    /* æ¶ˆæ¯æç¤ºæ¡† */
    .message-box {
        padding: 1rem;
        border-radius: var(--border-radius);
        margin-bottom: 1rem;
        font-weight: 500;
        display: none;
    }

    .message-box.error {
        background-color: #FEE2E2;
        color: #EF4444;
        border: 1px solid #FCA5A5;
    }

    .message-box.info {
        background-color: #E3F2FD;
        color: #1E88E5;
        border: 1px solid #90CAF9;
    }

    .message-box.success {
        background-color: #D1FAE5;
        color: #065F46;
        border: 1px solid #A7F3D0;
    }

    /* å“ˆå¸Œç»“æœåŒºåŸŸæ ·å¼ */
    .hash-result {
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .hash-label {
        flex-shrink: 0;
        width: 100px;
        font-weight: 600;
        color: #374151;
        font-size: 0.9rem;
    }

    .hash-result input {
        flex-grow: 1;
        padding: 0.75rem;
        border: 1px solid #D1D5DB;
        border-radius: 0.5rem;
        font-family: monospace;
        font-size: 0.9rem;
        background-color: #FFFFFF;
        color: #1F2937;
        overflow-x: auto;
    }

    .copy-button {
        flex-shrink: 0;
        padding: 0.75rem;
        background-color: #4CAF50;
        color: white;
        border: none;
        border-radius: 0.5rem;
        cursor: pointer;
        transition: background-color 0.2s;
    }

    .copy-button:hover {
        background-color: #45a049;
    }

    .copy-button.copied {
        background-color: #2196F3;
    }
</style>

<script>
    // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
    document.addEventListener('DOMContentLoaded', function () {
        const inputArea = document.getElementById('inputArea');
        const inputLengthSpan = document.getElementById('inputLength');
        const calculationStatus = document.getElementById('calculationStatus');
        const messageBox = document.getElementById('messageBox');

        const outputFields = {
            MD5: document.getElementById('hashMD5'),
            SHA1: document.getElementById('hashSHA1'),
            SHA256: document.getElementById('hashSHA256'),
            SHA512: document.getElementById('hashSHA512'),
        };

        // --- ä¿®å¤åçš„ MD5 å®ç° ---
        class MD5 {
            static rotateLeft(lValue, iShiftBits) {
                return (lValue << iShiftBits) | (lValue >>> (32 - iShiftBits));
            }

            static addUnsigned(lX, lY) {
                const lX8 = (lX & 0x80000000);
                const lY8 = (lY & 0x80000000);
                const lX4 = (lX & 0x40000000);
                const lY4 = (lY & 0x40000000);
                const lResult = (lX & 0x3FFFFFFF) + (lY & 0x3FFFFFFF);

                if (lX4 & lY4) {
                    return (lResult ^ 0x80000000 ^ lX8 ^ lY8);
                }
                if (lX4 | lY4) {
                    if (lResult & 0x40000000) {
                        return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);
                    } else {
                        return (lResult ^ 0x40000000 ^ lX8 ^ lY8);
                    }
                } else {
                    return (lResult ^ lX8 ^ lY8);
                }
            }

            static F(x, y, z) { return (x & y) | ((~x) & z); }
            static G(x, y, z) { return (x & z) | (y & (~z)); }
            static H(x, y, z) { return (x ^ y ^ z); }
            static I(x, y, z) { return (y ^ (x | (~z))); }

            static FF(a, b, c, d, x, s, ac) {
                a = this.addUnsigned(a, this.addUnsigned(this.addUnsigned(this.F(b, c, d), x), ac));
                return this.addUnsigned(this.rotateLeft(a, s), b);
            }

            static GG(a, b, c, d, x, s, ac) {
                a = this.addUnsigned(a, this.addUnsigned(this.addUnsigned(this.G(b, c, d), x), ac));
                return this.addUnsigned(this.rotateLeft(a, s), b);
            }

            static HH(a, b, c, d, x, s, ac) {
                a = this.addUnsigned(a, this.addUnsigned(this.addUnsigned(this.H(b, c, d), x), ac));
                return this.addUnsigned(this.rotateLeft(a, s), b);
            }

            static II(a, b, c, d, x, s, ac) {
                a = this.addUnsigned(a, this.addUnsigned(this.addUnsigned(this.I(b, c, d), x), ac));
                return this.addUnsigned(this.rotateLeft(a, s), b);
            }

            static convertToWordArray(string) {
                let lWordCount;
                const lMessageLength = string.length;
                const lNumberOfWords_temp1 = lMessageLength + 8;
                const lNumberOfWords_temp2 = (lNumberOfWords_temp1 - (lNumberOfWords_temp1 % 64)) / 64;
                const lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16;
                const lWordArray = new Array(lNumberOfWords);
                let lBytePosition = 0;
                let lByteCount = 0;

                // åˆå§‹åŒ–æ•°ç»„
                for (let i = 0; i < lNumberOfWords; i++) {
                    lWordArray[i] = 0;
                }

                while (lByteCount < lMessageLength) {
                    lWordCount = Math.floor(lByteCount / 4);
                    lBytePosition = (lByteCount % 4) * 8;
                    lWordArray[lWordCount] = lWordArray[lWordCount] | (string.charCodeAt(lByteCount) << lBytePosition);
                    lByteCount++;
                }

                lWordCount = Math.floor(lByteCount / 4);
                lBytePosition = (lByteCount % 4) * 8;
                lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80 << lBytePosition);
                lWordArray[lNumberOfWords - 2] = lMessageLength << 3;
                lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;

                return lWordArray;
            }

            static wordToHex(lValue) {
                let WordToHexValue = "";
                for (let lCount = 0; lCount <= 3; lCount++) {
                    const lByte = (lValue >>> (lCount * 8)) & 255;
                    WordToHexValue += ("0" + lByte.toString(16)).slice(-2);
                }
                return WordToHexValue;
            }

            static utf8Encode(string) {
                string = string.replace(/\r\n/g, "\n");
                let utftext = "";

                for (let n = 0; n < string.length; n++) {
                    const c = string.charCodeAt(n);

                    if (c < 128) {
                        utftext += String.fromCharCode(c);
                    } else if ((c > 127) && (c < 2048)) {
                        utftext += String.fromCharCode((c >> 6) | 192);
                        utftext += String.fromCharCode((c & 63) | 128);
                    } else {
                        utftext += String.fromCharCode((c >> 12) | 224);
                        utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                        utftext += String.fromCharCode((c & 63) | 128);
                    }
                }

                return utftext;
            }

            static init() {
                return [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476];
            }

            static calculate(string) {
                let x = this.convertToWordArray(this.utf8Encode(string));
                let a = this.init()[0], b = this.init()[1], c = this.init()[2], d = this.init()[3];

                for (let k = 0; k < x.length; k += 16) {
                    const AA = a, BB = b, CC = c, DD = d;

                    a = this.FF(a, b, c, d, x[k + 0], 7, 0xD76AA478);
                    d = this.FF(d, a, b, c, x[k + 1], 12, 0xE8C7B756);
                    c = this.FF(c, d, a, b, x[k + 2], 17, 0x242070DB);
                    b = this.FF(b, c, d, a, x[k + 3], 22, 0xC1BDCEEE);
                    a = this.FF(a, b, c, d, x[k + 4], 7, 0xF57C0FAF);
                    d = this.FF(d, a, b, c, x[k + 5], 12, 0x4787C62A);
                    c = this.FF(c, d, a, b, x[k + 6], 17, 0xA8304613);
                    b = this.FF(b, c, d, a, x[k + 7], 22, 0xFD469501);
                    a = this.FF(a, b, c, d, x[k + 8], 7, 0x698098D8);
                    d = this.FF(d, a, b, c, x[k + 9], 12, 0x8B44F7AF);
                    c = this.FF(c, d, a, b, x[k + 10], 17, 0xFFFF5BB1);
                    b = this.FF(b, c, d, a, x[k + 11], 22, 0x895CD7BE);
                    a = this.FF(a, b, c, d, x[k + 12], 7, 0x6B901122);
                    d = this.FF(d, a, b, c, x[k + 13], 12, 0xFD987193);
                    c = this.FF(c, d, a, b, x[k + 14], 17, 0xA679438E);
                    b = this.FF(b, c, d, a, x[k + 15], 22, 0x49B40821);

                    a = this.GG(a, b, c, d, x[k + 1], 5, 0xF61E2562);
                    d = this.GG(d, a, b, c, x[k + 6], 9, 0xC040B340);
                    c = this.GG(c, d, a, b, x[k + 11], 14, 0x265E5A51);
                    b = this.GG(b, c, d, a, x[k + 0], 20, 0xE9B6C7AA);
                    a = this.GG(a, b, c, d, x[k + 5], 5, 0xD62F105D);
                    d = this.GG(d, a, b, c, x[k + 10], 9, 0x02441453);
                    c = this.GG(c, d, a, b, x[k + 15], 14, 0xD8A1E681);
                    b = this.GG(b, c, d, a, x[k + 4], 20, 0xE7D3FBC8);
                    a = this.GG(a, b, c, d, x[k + 9], 5, 0x21E1CDE6);
                    d = this.GG(d, a, b, c, x[k + 14], 9, 0xC33707D6);
                    c = this.GG(c, d, a, b, x[k + 3], 14, 0xF4D50D87);
                    b = this.GG(b, c, d, a, x[k + 8], 20, 0x455A14ED);
                    a = this.GG(a, b, c, d, x[k + 13], 5, 0xA9E3E905);
                    d = this.GG(d, a, b, c, x[k + 2], 9, 0xFCEFA3F8);
                    c = this.GG(c, d, a, b, x[k + 7], 14, 0x676F02D9);
                    b = this.GG(b, c, d, a, x[k + 12], 20, 0x8D2A4C8A);

                    a = this.HH(a, b, c, d, x[k + 5], 4, 0xFFFA3942);
                    d = this.HH(d, a, b, c, x[k + 8], 11, 0x8771F681);
                    c = this.HH(c, d, a, b, x[k + 11], 16, 0x6D9D6122);
                    b = this.HH(b, c, d, a, x[k + 14], 23, 0xFDE5380C);
                    a = this.HH(a, b, c, d, x[k + 1], 4, 0xA4BEEA44);
                    d = this.HH(d, a, b, c, x[k + 4], 11, 0x4BDECFA9);
                    c = this.HH(c, d, a, b, x[k + 7], 16, 0xF6BB4B60);
                    b = this.HH(b, c, d, a, x[k + 10], 23, 0xBEBFBC70);
                    a = this.HH(a, b, c, d, x[k + 13], 4, 0x289B7EC6);
                    d = this.HH(d, a, b, c, x[k + 0], 11, 0xEAA127FA);
                    c = this.HH(c, d, a, b, x[k + 3], 16, 0xD4EF3085);
                    b = this.HH(b, c, d, a, x[k + 6], 23, 0x04881D05);
                    a = this.HH(a, b, c, d, x[k + 9], 4, 0xD9D4D039);
                    d = this.HH(d, a, b, c, x[k + 12], 11, 0xE6DB99E5);
                    c = this.HH(c, d, a, b, x[k + 15], 16, 0x1FA27CF8);
                    b = this.HH(b, c, d, a, x[k + 2], 23, 0xC4AC5665);

                    a = this.II(a, b, c, d, x[k + 0], 6, 0xF4292244);
                    d = this.II(d, a, b, c, x[k + 7], 10, 0x432AFF97);
                    c = this.II(c, d, a, b, x[k + 14], 15, 0xAB9423A7);
                    b = this.II(b, c, d, a, x[k + 5], 21, 0xFC93A039);
                    a = this.II(a, b, c, d, x[k + 12], 6, 0x655B59C3);
                    d = this.II(d, a, b, c, x[k + 3], 10, 0x8F0CCC92);
                    c = this.II(c, d, a, b, x[k + 10], 15, 0xFFEFF47D);
                    b = this.II(b, c, d, a, x[k + 1], 21, 0x85845DD1);
                    a = this.II(a, b, c, d, x[k + 8], 6, 0x6FA87E4F);
                    d = this.II(d, a, b, c, x[k + 15], 10, 0xFE2CE6E0);
                    c = this.II(c, d, a, b, x[k + 6], 15, 0xA3014314);
                    b = this.II(b, c, d, a, x[k + 13], 21, 0x4E0811A1);
                    a = this.II(a, b, c, d, x[k + 4], 6, 0xF7537E82);
                    d = this.II(d, a, b, c, x[k + 11], 10, 0xBD3AF235);
                    c = this.II(c, d, a, b, x[k + 2], 15, 0x2AD7D2BB);
                    b = this.II(b, c, d, a, x[k + 9], 21, 0xEB86D391);

                    a = this.addUnsigned(a, AA);
                    b = this.addUnsigned(b, BB);
                    c = this.addUnsigned(c, CC);
                    d = this.addUnsigned(d, DD);
                }

                const temp = this.wordToHex(a) + this.wordToHex(b) + this.wordToHex(c) + this.wordToHex(d);
                return temp.toLowerCase();
            }
        }

        // --- å·¥å…·å‡½æ•° ---
        /**
         * æ˜¾ç¤ºæ¶ˆæ¯æç¤º
         */
        function showMessage(message, type = 'info') {
            messageBox.textContent = message;
            messageBox.className = 'message-box';
            messageBox.classList.add(type);
            messageBox.style.display = 'block';

            setTimeout(() => {
                messageBox.style.display = 'none';
            }, 5000);
        }

        /**
         * å°† ArrayBuffer è½¬æ¢ä¸º 16 è¿›åˆ¶å­—ç¬¦ä¸²
         */
        function bufferToHex(buffer) {
            return Array.from(new Uint8Array(buffer))
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
        }

        /**
         * è®¡ç®— SHA ç®—æ³•çš„å“ˆå¸Œå€¼
         */
        async function computeSHAHash(text, algorithm) {
            if (typeof crypto === 'undefined' || !crypto.subtle) {
                throw new Error("æµè§ˆå™¨ä¸æ”¯æŒ Web Crypto APIã€‚");
            }

            const encoder = new TextEncoder();
            const data = encoder.encode(text);
            const hashBuffer = await crypto.subtle.digest(algorithm, data);
            return bufferToHex(hashBuffer);
        }

        /**
         * è®¡ç®—æ‰€æœ‰å“ˆå¸Œå¹¶æ›´æ–°è¾“å‡ºå­—æ®µ
         */
        async function calculateAllHashes() {
            messageBox.style.display = 'none';
            const input = inputArea.value;
            inputLengthSpan.textContent = input.length;

            if (input.length === 0) {
                Object.values(outputFields).forEach(field => field.value = '');
                calculationStatus.classList.add('hidden');
                return;
            }

            calculationStatus.classList.remove('hidden');

            try {
                // MD5 è®¡ç®—
                outputFields.MD5.value = MD5.calculate(input);

                // SHA ç³»åˆ—è®¡ç®—
                const shaAlgorithms = {
                    SHA1: 'SHA-1',
                    SHA256: 'SHA-256',
                    SHA512: 'SHA-512',
                };

                for (const [key, algorithm] of Object.entries(shaAlgorithms)) {
                    try {
                        const hash = await computeSHAHash(input, algorithm);
                        outputFields[key].value = hash;
                    } catch (error) {
                        console.error(`${key} Calculation Error:`, error);
                        outputFields[key].value = `Error: ${key} è®¡ç®—å¤±è´¥`;
                    }
                }

            } catch (error) {
                console.error("Hash Calculation Error:", error);
                showMessage("è®¡ç®—è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯ï¼Œè¯·é‡è¯•ã€‚", 'error');
            } finally {
                calculationStatus.classList.add('hidden');
            }
        }

        /**
         * æ¸…ç©ºæ‰€æœ‰è¾“å…¥å’Œè¾“å‡º
         */
        function clearAll() {
            inputArea.value = "";
            inputArea.focus();
            calculateAllHashes();
            showMessage("å·²æ¸…ç©ºè¾“å…¥åŒºåŸŸã€‚", 'info');
        }

        /**
         * å¤åˆ¶æŒ‡å®šçš„å“ˆå¸Œç»“æœåˆ°å‰ªè´´æ¿
         */
        async function copyHash(elementId) {
            const inputElement = document.getElementById(elementId);
            const output = inputElement.value;

            if (!output || output.startsWith('Error') || output === inputElement.placeholder) {
                showMessage("ç»“æœä¸ºç©ºæˆ–è®¡ç®—å¤±è´¥ï¼Œæ— æ³•å¤åˆ¶ã€‚", 'error');
                return;
            }

            try {
                await navigator.clipboard.writeText(output);

                const button = inputElement.nextElementSibling;
                const originalText = button.textContent;
                button.textContent = 'âœ…';
                button.classList.add('copied');

                showMessage(`${elementId.replace('hash', '')} å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼`, 'success');

                setTimeout(() => {
                    button.textContent = originalText;
                    button.classList.remove('copied');
                }, 2000);

            } catch (err) {
                // é™çº§æ–¹æ¡ˆ
                inputElement.select();
                document.execCommand('copy');
                showMessage(`${elementId.replace('hash', '')} å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼`, 'success');
            }
        }

        // --- äº‹ä»¶ç›‘å¬ ---
        let timeout = null;
        inputArea.addEventListener('input', function () {
            clearTimeout(timeout);
            timeout = setTimeout(calculateAllHashes, 200);
        });

        // ç«‹å³è®¡ç®—ä¸€æ¬¡ï¼ˆå¤„ç†å¯èƒ½çš„åˆå§‹å†…å®¹ï¼‰
        calculateAllHashes();

        // å°†å‡½æ•°æš´éœ²åˆ°å…¨å±€ä½œç”¨åŸŸ
        window.clearAll = clearAll;
        window.copyHash = copyHash;
    });
</script>
{{ end }}